# BOJ 4913 페르마의 크리스마스 정리

## Fact

1. 두 제곱수의 합으로 나타낼 수 있는 소수가 있다.
2. 어떠한 구간이 주어졌을 때 그 구간에 포함되어 있는 소수를 제곱수의 합으로 나타낼 수 있는 경우의 수를 구한다.

- 입력
  1. 여러개의 테스트 케이스가 각각 한 줄로 이루어진다.
  2. L과 U가 공백으로 구분되어 주어진다. (L <= U < 1,000,000)
  3. 입력의 끝은 L과 U를 -1로 표기한다.
- 출력
  1. 각 테스트 케이스에 대해 한 줄에 L U x y 를 출력한다.
  2. L U는 입력으로 주어진 값
  3. x는 구간 [L, U]에 포함된 소수의 개수
  4. y는 [L, U]에 포함된 소수 중 제곱수의 합으로 나타낼 수 있는 것의 개수

## Overview

[L, U] 에 포함된 소수의 개수와, 그 소수들 중 제곱수의 합으로 나타낼 수 있는 소수들의 개수를 구하는 프로그램

## Algorithm

1. 소수를 구하는 algorithm을 먼저 생각해 보았다.

   - 가장 기본적으로 생각할 수 있는 알고리즘

   ```c++
   for(int i = L ; i <= U ; i ++){
   	for(int j = L ; j <= sqrt(L) ; j++){
           if( i % j == 0)
           	break;
       }
       if(j > sqr(i))
       	cout << i ;
   }
   ```

   ​	L과 U가 1,000,000미만의 수 이기 때문에, n의 값이 커지면 기하급수적으로 

   ​	느려질 수도 있겠다는 생각이 들었다.

   - **에라토스테네스의 체** 알고리즘
     - 구하고자 하는 범위의 수를 모두 array에 넣은 후 소수가 아닌 것들을 모두 버리는 것

   ```c++
   for(int i = 2 ; i <= MAX ; i++) 
       a1[i] = i;
   for(int i = 2 ; i <= (int)sqrt(MAX) ; i ++) {
   	if(a1[i] == 0)		//이미 확인한 수의 배수는 2번 확인하지않음
   		continue;
   	for(int j = i+i ; j <= MAX ; j += i) {
   		if(a1[j]%i == 0)
               a1[j] = 0;	//i를 제외한 i의 배수들은 0으로 초기화
       }
   }
   
   for(int i = 2 ; i <= MAX ; i++)
       if(a1[i] != 0)		//걸러진 소수들을 vector에 다시 입력
           a2.push_back(a1[i]);
   ```

2. 범위 안의 소수들을 모두 찾아냈다면, 그 값에서 다시 제곱수의 합으로 나타낼 수 있는 수를 찾는다.

   ```c++
   if(a2[i] % 4 == 1)
   	count++;
   ```

3. 위의 방법으로 `L ==2 && U == 2`일 때,prime number 2를 걸러내지 못한다는 것을 알아냈다.

   - 따라서, 결과 값을 확인하기 전에 L과 U가 모두 2일때 제곱수의 합으로 나타낼 수 있는 소수의 갯수를 +1 해준다.

### Time Complexity

O(nlogn)

### Space Complexity

O(n)
